from keras.models import Sequential
from keras.layers import (
    Dense,
    Conv2D,
    Flatten,
    MaxPooling2D,
    BatchNormalization,
    Dropout,
)
from sklearn.model_selection import train_test_split
import numpy as np
from datetime import datetime
import os


# Define a schedule function:
def scheduler(epoch, lr):
    if epoch < 10:
        return lr
    else:
        return lr * 0.9  # Decrease lr by 10% after the 10th epoch


def create_cnn_model(input_shape):
    model = Sequential(
        [
            # First block of convolutions and pooling
            Conv2D(
                32, (3, 3), padding="same", input_shape=input_shape, activation="relu"
            ),
            Conv2D(32, (3, 3), activation="relu"),
            MaxPooling2D(pool_size=(2, 2)),
            BatchNormalization(),
            # Second block of convolutions and pooling
            Conv2D(64, (3, 3), padding="same", activation="relu"),
            Conv2D(64, (3, 3), activation="relu"),
            MaxPooling2D(pool_size=(2, 2)),
            BatchNormalization(),
            Dropout(0.2),
            # Flattening and Dense layers
            Flatten(),
            Dense(100, activation="relu"),
            Dense(10, activation="relu"),
            Dense(1, activation="sigmoid"),
        ]
    )

    # Compiling the model.
    model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])

    return model


def train_model(
    model,
    train_x,
    train_y,
    validation_data,
    epochs,
    callbacks=None,
    early_stopping=None,
    lr_scheduler=None,
):
    history = model.fit(
        train_x,
        train_y,
        epochs=epochs,
        validation_data=validation_data,
        shuffle=True,
        callbacks=[callbacks, early_stopping, lr_scheduler],
    )
    return history


def load_data(img_list_path, labels_path):
    try:
        # Loading prepared samples
        train_img_list = np.load(img_list_path)
        labels = np.load(labels_path)
        return train_img_list, labels

    except FileNotFoundError as e:
        print(f"Error: {e.strerror}. File {e.filename} not found.")
        # Handle the error by possibly exiting the script, or providing an alternative data source
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        # Handle any other exception that might occur

        return None, None


def split_data(train_img_list, labels, train_size, validation_size, test_size):
    # First split the data into training + validation and test sets
    train_val_x, test_x, train_val_y, test_y = train_test_split(
        train_img_list, labels, test_size=test_size, random_state=25
    )

    # Adjust train size for the remaining dataset
    train_size_adjusted = train_size / (1 - test_size)

    # Then split the training + validation set into separate training and validation sets
    train_x, val_x, train_y, val_y = train_test_split(
        train_val_x, train_val_y, test_size=1 - train_size_adjusted, random_state=25
    )

    return train_x, val_x, train_y, val_y, test_x, test_y


def save_results_to_file(history, test_accuracy, memo, base_dir):
    # Generate a timestamp for the filename
    date_time_str = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    file_name = f"results_{date_time_str}.txt"
    file_path = os.path.join(base_dir, "original", file_name)

    # Ensure the base directory exists
    os.makedirs(os.path.dirname(file_path), exist_ok=True)

    with open(file_path, "w") as file:
        # Writing memo at the start of the file
        file.write(memo + "\n\n")

        # Writing training and validation results per epoch
        for i in range(len(history.history["accuracy"])):
            file.write(f"Epoch {i+1}/{len(history.history['accuracy'])}\n")
            file.write(f"Training Accuracy: {history.history['accuracy'][i]}\n")
            file.write(f"Validation Accuracy: {history.history['val_accuracy'][i]}\n")
            file.write(f"Training Loss: {history.history['loss'][i]}\n")
            file.write(f"Validation Loss: {history.history['val_loss'][i]}\n\n")

        # Writing test results
        file.write(f"Test Accuracy: {test_accuracy * 100:.2f}%\n")
